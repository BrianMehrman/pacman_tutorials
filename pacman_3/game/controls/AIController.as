package game.controls {	import game.objects.GameObject;	import flash.events.Event;	import flash.utils.getQualifiedClassName;	import flash.utils.getQualifiedSuperclassName;	import game.objects.TargetTileMovement;	import game.objects.MovementEvent;	import game.objects.MovementHandler;	import game.ai.pathfinding.MapNode;	import game.ai.pathfinding.IPathfinder;	import game.GameEvent;		public class AIController {		public static const STATE_FEAR		= "frighten";		public static const STATE_SCATTER	= "scatter";		public static const STATE_CHASE		= "chase";				protected var _currentState:String;		protected var _gameObject:GameObject;		protected var _pathfinder:IPathfinder;		protected var _movementHandler:MovementHandler;						public function AIController(gameObject:GameObject, movementHandler:MovementHandler, pathfinder:IPathfinder):void {			// constructor code			this._gameObject = gameObject;			this._currentState = "";			this._movementHandler = movementHandler;			this._pathfinder = pathfinder;			// add		}				public function startListening():void {			this._gameObject.addEventListener(Event.ENTER_FRAME, checkLoop);		}				public function stopListening():void {			//if (this._gameObject.stage)			this._gameObject.removeEventListener(Event.ENTER_FRAME, checkLoop);		}				/*		 * Check Loop		 *		 * Check to see if the state should change or the target should change		 *		 */		protected function checkLoop(e:Event):void {			// check to see what state I should be in			// if i have no target i have nothing to do, i should return and try again later			if(this._gameObject.targetObject == null) {				if(this._movementHandler.game.clientHero == null){					return;				} else {					this._gameObject.targetObject = this._movementHandler.game.clientHero;				}			}			var state:String = this._movementHandler.game.currentState;			var canChangeDirection:Boolean = this._gameObject.canChangeDirection();			checkHitTarget();			if(state != this._currentState || canChangeDirection){								this._currentState = state;				this._gameObject[state]();			}				// check to see if i am in an intersection		}				/*		 * Target Change		 *		 * Controls which tile to target next and changes the ai to that target.		 * 		 * Using the current target this function will determine which tile the target is one, then using its current		 * state target pattern (this should be a function) find the tile it should be targeting. Set AI controller's		 * 'newTarget' to that tile.		 * 		 */		protected function targetChange():void{			// get current target					}				/*		 *  State Change		 *		 *  Controls which state the enemy will change to when a state change is called		 *		 *  The state change is triggered by a time that will dispatch the stage change event. The function then		 *  looks at the current state and the hero's state to determine which state the enemy should be in. Current		 *  state available should be chase, frightened, scatter. 		 */		protected function stateChange():void {					}				/**		 *		 * hitTarget		 *		 * Check to see if this object has hit it's target.		 *		 **/		protected function checkHitTarget():void {			if(this._gameObject.targetObject == null) return;			if(this._gameObject.hitTestObject(this._gameObject.targetObject)) {				this._gameObject.stage.dispatchEvent(new GameEvent(GameEvent.PLAYER_HIT, 1, this._gameObject.targetObject));			}		}				/**		 * 		 * Checks if the clientHero is past the half-way point in his tile movement.  If so, we need to move an		 * extra tile on top of one we're already moving.		 * 		 * @return A <code>Vector.<uint></code> containing the x and y tiles to move to.  The first element is the		 * x tile, the second is the y.		 * 		 */				protected function checkExtraTiles():Vector.<uint> {			var returnTiles:Vector.<uint> = new Vector.<uint>();						returnTiles[0] =				(					(this._gameObject.moveDirX > 0 && this._gameObject.x%this._movementHandler.game.tileW > this._movementHandler.game.tileW/2) ||					(this._gameObject.moveDirX < 0 && this._gameObject.x%this._movementHandler.game.tileW < this._movementHandler.game.tileW/2)				) ?				this._gameObject.xTile + this._gameObject.moveDirX :				this._gameObject.xTile;						returnTiles[1] =				(					(this._gameObject.moveDirY > 0 && this._gameObject.y%this._movementHandler.game.tileH > this._movementHandler.game.tileH/2) ||					(this._gameObject.moveDirY < 0 && this._gameObject.y%this._movementHandler.game.tileH < this._movementHandler.game.tileH/2)				) ?				this._gameObject.yTile + this._gameObject.moveDirY :				this._gameObject.yTile;						return returnTiles;		}		public function newTarget(destX:Number, destY:Number):void {			// if destination is not solid keep moving towards game object until non solid tile found			var origDestX:int = destX;			var origDestY:int = destY;			var vecX:int = 0;			var vecY:int = 0;			var arr:Array;						if ( destX < 0) {				destX = 0;			} else if ( destX >= this._movementHandler.game.mapWidth) {				destX = this._movementHandler.game.mapWidth - 1;			}						if ( destY < 0 ) {				destY = 0;			} else if ( destY >= this._movementHandler.game.mapHeight) {				destY = this._movementHandler.game.mapHeight - 1;			}						while(this._movementHandler.game.gameTiles[destX][destY].solid ) {								if( destX < 0 || destX >= this._movementHandler.game.mapWidth || destY < 0 || destY >= this._movementHandler.game.mapHeight) {					break;				}				vecX = (this._gameObject.xTile - destX > 0) ? 1 : -1;				vecY = (this._gameObject.yTile - destY > 0) ? 1 : -1;				arr  = [					[destX-1, destY],					[destX+1,destY],					[destX, destY-1],					[destX, destY+1]				];								for each(var checkNodeCoords:Array in arr) {					if(checkNodeCoords[0] >= 0 &&						 checkNodeCoords[0] < this._movementHandler.game.mapWidth &&						 checkNodeCoords[1] >= 0 &&						 checkNodeCoords[1] < this._movementHandler.game.mapHeight) {						if(!this._movementHandler.game.gameTiles[checkNodeCoords[0]][checkNodeCoords[1]].solid) {							destX = checkNodeCoords[0];							destY = checkNodeCoords[1];							break;						}					}				}				if(this._movementHandler.game.gameTiles[destX][destY].solid) {					destX += vecX;					destY += vecY;				}			}			// if dest is equal to current location but not original location 			if ((this._gameObject.xTile == destX && this._gameObject.yTile == destY) 					&& ( destX != origDestX || destY != origDestY)) {					// check the next tile to see if it is open										if(!this._movementHandler.game.gameTiles[this._gameObject.dirX+destX][this._gameObject.dirY+destY].solid){					// if not then loop through cardinal directions to find the next open tile						destX = this._gameObject.dirX+destX;						destY = this._gameObject.dirY+destY;					} else {						arr  = [							[destX-1, destY],							[destX+1,destY],							[destX, destY-1],							[destX, destY+1]						];												for each(var checkNodeCoords:Array in arr) {							if(checkNodeCoords[0] >= 0 &&						 		checkNodeCoords[0] < this._movementHandler.game.mapWidth &&						 		checkNodeCoords[1] >= 0 &&						 		checkNodeCoords[1] < this._movementHandler.game.mapHeight) {								if(!this._movementHandler.game.gameTiles[checkNodeCoords[0]][checkNodeCoords[1]].solid) {									destX = checkNodeCoords[0];									destY = checkNodeCoords[1];									break;								}							}						}					}			}			this._gameObject.targetTileX = destX;			this._gameObject.targetTileY = destY;			this._gameObject.previousNode = new MapNode(this._gameObject.xTile, this._gameObject.yTile, this._gameObject.currentPath);									if(!this._movementHandler.game.gameTiles[destX][destY].solid && (this._gameObject.xTile != origDestX || this._gameObject.yTile != origDestY)) {								var path:Vector.<MapNode>;								if(this._gameObject.targetTileMovement == null) {					path = this._pathfinder.findPath(this._gameObject.xTile, this._gameObject.yTile, destX, destY, this._movementHandler.game.gameTiles, this._gameObject.previousNode);					path = this._pathfinder.getCorners(path);					this._gameObject.currentPath = path;					this.followPath();				} else {										var tiles:Vector.<uint> = this.checkExtraTiles();										path = this._pathfinder.findPath(tiles[0], tiles[1], destX, destY, this._movementHandler.game.gameTiles, this._gameObject.previousNode);					path = this._pathfinder.getCorners(path);										this._gameObject.currentPath = path;					this._gameObject.targetTileMovement = new TargetTileMovement(tiles[0], tiles[1], this._gameObject.dirX, this._gameObject.dirY);				}				this._movementHandler.addEventListener(MovementEvent.TILE_MOVEMENT_OVER, this.followPath);			}		}				protected function followPath(event:MovementEvent = null):void {			if ((event != null && this._gameObject != event.gameObject) || this._movementHandler.game.gamePaused) return;			if(this._gameObject.currentPath && this._gameObject.currentPath.length != 0) {												var nextNode:MapNode = this._gameObject.currentPath.shift();				this._gameObject.previousNode = nextNode;				var dirX:int = 0;				var dirY:int = 0;								if (nextNode.xCoord < this._gameObject.xTile) {					dirX = -1;				} else if(nextNode.xCoord > this._gameObject.xTile) {					dirX = 1;				} else if(nextNode.yCoord < this._gameObject.yTile) {					dirY = -1;				} else if(nextNode.yCoord > this._gameObject.yTile) {					dirY = 1;				}								this._gameObject.targetTileMovement = new TargetTileMovement(nextNode.xCoord, nextNode.yCoord, dirX, dirY);								this._movementHandler.finishTileMovement(this._gameObject);						} else {				this._gameObject.targetTileMovement = null;				this._gameObject.stopCurAnim();								this._gameObject.triggerCurrentState();			}		}	}	}