package game.controls {		import game.Game;	import game.ai.pathfinding.IPathfinder;	import game.ai.pathfinding.MapNode;	import game.map.Tile;	import game.objects.JumpState;	import game.objects.MovementEvent;	import game.objects.MovementHandler;	import game.objects.TargetTileMovement;		import flash.events.Event;	import flash.events.MouseEvent;	import flash.utils.getQualifiedClassName;	import flash.utils.getQualifiedSuperclassName;	 	public class Controls {		protected var _game:Game;		public var _movementHandler:MovementHandler;		protected var _inputHandler:InputHandler;		protected var _pathfinder:IPathfinder;		protected var _lockableKeys:Array = [32];		protected var _lockedKeys:Array = new Array();				public function Controls(game:Game, movementHandler:MovementHandler, inputHandler:InputHandler, pathfinder:IPathfinder) {			// constructor code			this._game = game;			this._movementHandler = movementHandler;			this._inputHandler = inputHandler;			this._pathfinder = pathfinder;		}				public function startListening():void {			if(this._game.movementType != Game.CLICK) {				this._inputHandler.addEventListener(KeyEvent.KEYS_DOWN, this.handleKeyDown);				this._inputHandler.addEventListener(KeyEvent.NO_KEY_DOWN, this.handleNoKeyDown);			} else {				this._game.tilesContainer.addEventListener(MouseEvent.CLICK, this.handleClick);			}		}				public function stopListening():void {			if(this._game.movementType != Game.CLICK) {				this._inputHandler.removeEventListener(KeyEvent.KEYS_DOWN, this.handleKeyDown);				this._inputHandler.removeEventListener(KeyEvent.NO_KEY_DOWN, this.handleNoKeyDown);			} else {				this._game.tilesContainer.removeEventListener(MouseEvent.CLICK, this.handleClick);			}		}				public function startHeroJump():void {			if(this._game.clientHero.jumpState == null) {				var forwardSpeed:Number = this._game.clientHero.speed;				if(this._game.clientHero.moveDirX == 0 && this._game.clientHero.moveDirY == 0) {					forwardSpeed = 0;				}								var jumpState:JumpState = new JumpState(0, this._game.clientHero.jumpSpeed, forwardSpeed, this._game.clientHero.moveDirX, this._game.clientHero.moveDirY, this._game.clientHero.dirX, this._game.clientHero.dirY);								this._movementHandler.startJump(this._game.clientHero, this._game.clientHero.moveDirX, this._game.clientHero.moveDirY, this._game.clientHero.dirX, this._game.clientHero.dirY, jumpState);			}		}				protected function handleKeyDown(keyEvent:KeyEvent):void {			for each(var key:int in this._lockableKeys) {				if(keyEvent.keys[key]) {					if(this._lockedKeys[key]) {						delete keyEvent.keys[key];					} else {						this._lockedKeys[key] = true;					}				} else if(this._lockedKeys[key]) {					delete this._lockedKeys[key];				}			}						// 32 = space			if(keyEvent.keys[32] && this._game.movementType == Game.NORMAL) {				this.startHeroJump();			}						var speed:int;						if(this._game.clientHero.jumpState == null) {				speed = this._game.clientHero.speed;			} else {				speed = this._game.clientHero.directionalInfluence;			}			//87 = w			if(keyEvent.keys[87]) {				trace("up");				this._movementHandler.moveObject(this._game.clientHero, 0, -1, 0, -1, speed, this._game.clientHero.jumpState);				//65 = a			} else if(keyEvent.keys[65]) {				trace("left");				this._movementHandler.moveObject(this._game.clientHero, -1, 0, -1, 0, speed, this._game.clientHero.jumpState);				//83 = s			} else if(keyEvent.keys[83]) {				trace("down");				this._movementHandler.moveObject(this._game.clientHero, 0, 1, 0, 1, speed, this._game.clientHero.jumpState);				//68 = d			} else if(keyEvent.keys[68]) {				trace("right");				this._movementHandler.moveObject(this._game.clientHero, 1, 0, 1, 0, speed, this._game.clientHero.jumpState);				//69 = e, 81 = q			} else if(this._game.strafing && (keyEvent.keys[69] || keyEvent.keys[81])) {				var moveDirX:int = 0;				var moveDirY:int = 0;				trace("strafe");				if(this._game.clientHero.dirY != 0) {					moveDirX = 1;				} else if(this._game.clientHero.dirX != 0) {					moveDirY = 1;				}								if(keyEvent.keys[81]) {					trace("strafe_left");					moveDirX *= -1;					moveDirY *= -1;				}								this._movementHandler.moveObject(this._game.clientHero, moveDirX, moveDirY, this._game.clientHero.dirX, this._game.clientHero.dirY, speed, this._game.clientHero.jumpState);			}		}				protected function handleNoKeyDown(keyEvent:KeyEvent):void {			this._lockedKeys = new Array();			trace("no key down");			if(this._game.movementType == Game.NORMAL && this._game.clientHero.jumpState == null) {				this._game.clientHero.stopCurAnim();			} else if(this._game.movementType == Game.TILE_BY_TILE) {				var tiles:Vector.<uint> = this.checkExtraTiles();				this._game.clientHero.targetTileMovement = new TargetTileMovement(tiles[0], tiles[1], this._game.clientHero.dirX, this._game.clientHero.dirY);								this._movementHandler.finishTileMovement(this._game.clientHero);			}		}				/**		 * 		 * Checks if the clientHero is past the half-way point in his tile movement.  If so, we need to move an		 * extra tile on top of one we're already moving.		 * 		 * @return A <code>Vector.<uint></code> containing the x and y tiles to move to.  The first element is the		 * x tile, the second is the y.		 * 		 */				protected function checkExtraTiles():Vector.<uint> {			var returnTiles:Vector.<uint> = new Vector.<uint>();						returnTiles[0] =				(					(this._game.clientHero.moveDirX > 0 && this._game.clientHero.x%this._game.tileW > this._game.tileW/2) ||					(this._game.clientHero.moveDirX < 0 && this._game.clientHero.x%this._game.tileW < this._game.tileW/2)				) ?				this._game.clientHero.xTile + this._game.clientHero.moveDirX :				this._game.clientHero.xTile;						returnTiles[1] =				(					(this._game.clientHero.moveDirY > 0 && this._game.clientHero.y%this._game.tileH > this._game.tileH/2) ||					(this._game.clientHero.moveDirY < 0 && this._game.clientHero.y%this._game.tileH < this._game.tileH/2)				) ?				this._game.clientHero.yTile + this._game.clientHero.moveDirY :				this._game.clientHero.yTile;						return returnTiles;		}		protected function handleClick(event:MouseEvent):void {			if(flash.utils.getQualifiedSuperclassName(event.target) == "game.map::Tile") {				var destX = Math.floor(event.currentTarget.mouseX/this._game.tileW);				var destY = Math.floor(event.currentTarget.mouseY/this._game.tileH);								if(!this._game.gameTiles[destX][destY].solid && (this._game.clientHero.xTile != destX || this._game.clientHero.yTile != destY)) {										var path:Vector.<MapNode>;										if(this._game.clientHero.targetTileMovement == null) {						// Set new target						path = this._pathfinder.findPath(this._game.clientHero.xTile, this._game.clientHero.yTile, destX, destY, this._game.gameTiles);						path = this._pathfinder.getCorners(path);						this._game.clientHero.currentPath = path;												this.followPath();					} else {						// Change target						var tiles:Vector.<uint> = this.checkExtraTiles();												path = this._pathfinder.findPath(tiles[0], tiles[1], destX, destY, this._game.gameTiles);						path = this._pathfinder.getCorners(path);												this._game.clientHero.currentPath = path;												this._game.clientHero.targetTileMovement = new TargetTileMovement(tiles[0], tiles[1], this._game.clientHero.dirX, this._game.clientHero.dirY);					}					this._movementHandler.addEventListener(MovementEvent.TILE_MOVEMENT_OVER, this.followPath);				}			}		}				protected function followPath(event:MovementEvent = null):void {			if(this._game.clientHero.currentPath && this._game.clientHero.currentPath.length != 0) {				var nextNode:MapNode = this._game.clientHero.currentPath.shift();								var dirX:int = 0;				var dirY:int = 0;								if(nextNode.xCoord < this._game.clientHero.xTile) {					dirX = -1;				} else if(nextNode.xCoord > this._game.clientHero.xTile) {					dirX = 1;				}								if(nextNode.yCoord < this._game.clientHero.yTile) {					dirY = -1;				} else if(nextNode.yCoord > this._game.clientHero.yTile) {					dirY = 1;				}								this._game.clientHero.targetTileMovement = new TargetTileMovement(nextNode.xCoord, nextNode.yCoord, dirX, dirY);								this._movementHandler.finishTileMovement(this._game.clientHero);			} else {				this._game.clientHero.targetTileMovement = null;				this._game.clientHero.stopCurAnim();			}		}			}	}