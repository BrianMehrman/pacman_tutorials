package game.ai.pathfinding {		/**	 *	 * Pathfinding via the A* algorithm.	 *	 */	public class AStar implements IPathfinder {		public function AStar() {		}		/**		 *		 * Finds the path.		 *		 * @param curX The current x tile coordinate.		 * @param curY The current y tile coordinate.		 * @param destX The destination x tile coordinate.		 * @param destY The destination y tile coordinate.		 * @param gameTiles The <code>Object</code> containing the x, y coordinate pairs and associated Tile objects		 * of all the game's tiles.		 *		 * @return A <code>Vector.<MapNode> containing the path from the starting <code>MapNode</code> to the ending <code>MapNode</code>.		 *		 */		public function findPath(curX:uint, curY:uint, destX:uint, destY:uint, gameTiles:Object):Vector.<MapNode> {			var openList:Vector.<AStarNode> = new Vector.<AStarNode>();			var closedList:Vector.<AStarNode> = new Vector.<AStarNode>();			openList[0] = new AStarNode(curX, curY, new Vector.<MapNode>(), 0, this.calculateHeuristic(curX, curY, destX, destY));			var lowestFNode:String;			while(true) {				for (var nodeIndex:String in openList) {					if(!lowestFNode) {						lowestFNode = nodeIndex;					} else if(openList[nodeIndex].g + openList[nodeIndex].h < openList[lowestFNode].g + openList[lowestFNode].h) {						lowestFNode = nodeIndex;					}				}				closedList[closedList.length] = openList[lowestFNode];				openList.splice(Number(lowestFNode), 1);				var validAdjacentNodes:Vector.<AStarNode> = this.validAdjacentNodes(closedList[closedList.length-1], gameTiles);				var indexInOpenList:String;				var indexInClosedList:String;				for each(var node:AStarNode in validAdjacentNodes) {					indexInOpenList = this.indexInList(openList, node);					indexInClosedList = this.indexInList(closedList, node);					if(indexInOpenList != "-1" && openList[indexInOpenList].g < node.g) {						openList[indexInOpenList] = node;					} else if(indexInOpenList == "-1" && indexInClosedList == "-1") {						openList[openList.length] = node;					}				}				if(closedList[closedList.length-1].xCoord == destX && closedList[closedList.length-1].yCoord == destY) {					var pathToNode:Vector.<MapNode> = closedList[closedList.length-1].pathToNode;					pathToNode.push(closedList[closedList.length-1] as MapNode);					return pathToNode;				} else if(openList.length == 0) {					return new Vector.<MapNode>();				}			}			return new Vector.<MapNode>();		}		/**		 *		 * Gets the index of a <code>MapNode</code> in a list (open or closed) of nodes.		 *		 * @param list The list of nodes.		 * @param targetNode The node to find the index.		 *		 * @return The index of the passed <code>MapNode</code>		 *		 */		protected function indexInList(list:Vector.<AStarNode>, targetNode:MapNode):String {			for(var nodeIndex:String in list) {				if(list[nodeIndex].xCoord == targetNode.xCoord && list[nodeIndex].yCoord == targetNode.yCoord) {					return nodeIndex;				}			}			return "-1";		}		/**		 *		 * Gets the valid adjacent nodes to the passed node.		 *		 * @param currentNode The <code>AStarNode</code> we are getting adjacent nodes for.		 * @param gameTiles The <code>Object</code> containing the x, y coordinate pairs and associated Tile objects		 * of all the game's tiles.		 *		 * @return A <code>Vector.<AStarNode> containing all of the adjacent nodes.		 *		 */		protected function validAdjacentNodes(currentNode:AStarNode, gameTiles:Object):Vector.<AStarNode> {			var nodesToCheck:Array = [				[currentNode.xCoord-1, currentNode.yCoord],				[currentNode.xCoord+1, currentNode.yCoord],				[currentNode.xCoord, currentNode.yCoord-1],				[currentNode.xCoord, currentNode.yCoord+1]			];			var checkedNodes:Vector.<AStarNode> = new Vector.<AStarNode>();			var pathToNode:Vector.<MapNode>;			for each(var checkNodeCoords:Array in nodesToCheck) {				if(this.validNode(checkNodeCoords[0], checkNodeCoords[1], gameTiles)) {					pathToNode = currentNode.pathToNode.slice();					pathToNode.push(currentNode as MapNode);					checkedNodes[checkedNodes.length] = new AStarNode(checkNodeCoords[0], checkNodeCoords[1], pathToNode, currentNode.g + this.calculateMovementCost(checkNodeCoords[0], checkNodeCoords[1], gameTiles), this.calculateHeuristic(currentNode.xCoord, currentNode.yCoord, checkNodeCoords[0], checkNodeCoords[1]));				}			}			return checkedNodes;		}		/**		 *		 * Checks if a node is valid.  Invalid nodes (tiles) are outside of  boundaries or are not walkable.		 *		 * @param xCoord The x tile coordinate of the node.		 * @param yCoord The y tile coordinate of the node.		 * @param gameTiles The <code>Object</code> containing the x, y coordinate pairs and associated Tile objects		 * of all the game's tiles.		 *		 * @return <code>true</code> if the node is valid, <code>false</code> if it is not.		 *		 */		protected function validNode(xCoord:uint, yCoord:uint, gameTiles:Object):Boolean {			if(				(xCoord < 0 || xCoord > gameTiles[0].length) || // Tile is outside  bounds on x plane.				(yCoord < 0 || yCoord > gameTiles.length) || // Tile is outside  bounds on y plane.				(gameTiles[xCoord][yCoord].solid) // Tile is not walkable.			) {				return false;			}			return true;		}		/**		 *		 * Calculates the movement cost to move into the passed node.		 *		 * @param targetX The x tile coordinate of the node we are checking.		 * @param targetY The y tile coordinate of the node we are checking.		 * @param gameTiles The <code>Object</code> containing the x, y coordinate pairs and associated Tile objects		 * of all the game's tiles.		 *		 */		protected function calculateMovementCost(targetX:uint, targetY:uint, gameTiles:Object) {			return 10;		}		/**		 *		 * Calculates the heuristic (H) value from the passed current node to the passed destination node.		 *		 * @param curX The x tile coordinate of the node we are checking.		 * @param curY The y tile coordinate of the node we are checking.		 * @param destX The x tile coordinate of the destination node.		 * @param destY The y tile coordinate of the destination node.		 *		 */		protected function calculateHeuristic(curX:uint, curY:uint, destX:uint, destY:uint) {			return 10*(Math.abs(curX-destX) + Math.abs(curY-destY));		}		/**		 *		 * Gets the corners from a path.		 *		 * @param path The path containing the <code>MapNodes</code>s.		 *		 * @return An <code>Vector.<MapNode><code> containing the corner <code>MapNode</code>s in the path.		 *		 */		public function getCorners(path:Vector.<MapNode>):Vector.<MapNode> {			var corners:Vector.<MapNode> = new Vector.<MapNode>();			for (var key:String in path) {				var numberKey:Number = Number(key);				if(numberKey == path.length-1) {					corners.push(path[numberKey]);				} else if(					numberKey != 0 &&					path[numberKey-1].xCoord != path[numberKey+1].xCoord &&					path[numberKey-1].yCoord != path[numberKey+1].yCoord				) {					corners.push(path[numberKey]);				}			}			return corners;		}	}	}