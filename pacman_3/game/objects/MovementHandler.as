package game.objects {		import game.content.tiles.*;	import game.Game;	import game.map.Tile;		import flash.events.Event;	import flash.events.EventDispatcher;	import flash.utils.getDefinitionByName;		public class MovementHandler extends EventDispatcher {		protected var _game:Game;				public function MovementHandler(game:Game) {			// constructor code			this._game = game;		}				public function get game():Game {			return this._game;		}				public function set game(g:Game):void {			this._game = g;		}		/**		 *		 * Gets the tiles that are touching the corners of the object.		 *		 * @param destX The hypothetical destination x coordinate of the object.		 * @param destY The hypothetical destination y coordinate of the object.		 * @param object The game object.		 *		 * @return An array with the <code>Tile</code> objects that touch the corners of the passed <code>GameObject</code>.		 *		 */		public function getCorners(destX:int, destY:int, object:GameObject):Object {			var FillerTileClass:Object = getDefinitionByName(Game.FILLER_TILE_CLASS);			var top = this.getYTilesFromY(destY-object.halfHeight);			var bottom = this.getYTilesFromY(destY+object.halfHeight);			var left = this.getXTilesFromX(destX-object.halfWidth);			var right = this.getXTilesFromX(destX+object.halfWidth);			var corners:Object = new Object();			corners["topLeft"] = (this._game.gameTiles[left] && this._game.gameTiles[left][top]) ? this._game.gameTiles[left][top] : new FillerTileClass();			corners["topRight"] = (this._game.gameTiles[right] && this._game.gameTiles[right][top]) ? this._game.gameTiles[right][top] : new FillerTileClass();			corners["bottomLeft"] = (this._game.gameTiles[left] && this._game.gameTiles[left][bottom]) ? this._game.gameTiles[left][bottom] : new FillerTileClass();			corners["bottomRight"] = (this._game.gameTiles[right] && this._game.gameTiles[right][bottom]) ? this._game.gameTiles[right][bottom] : new FillerTileClass();			return corners;		}		/**		 * Check if the passed movement is valid.  Used only in tile-by-tile movement.		 *		 * @param object The <code>GameObject</code> to move.		 * @param moveDirX The direction to move the object on the x plane. -1, 0, or 1.		 * @param moveDirY The direction to move the object on the y plane. -1, 0, or 1.		 * @param dirX The direction the object is facing on the x plane. -1, 0, or 1.		 * @param dirY The direction the object is facing on the y plane. -1, 0, or 1.		 * @param finishingMovement <code>true</code> if the call is to finish a movement, <code>false</code> if not.		 *		 * @return <code>true</code> if valid, <code>false</code> if not.		 *		 */		protected function checkMovement(object:GameObject, moveDirX:int, moveDirY:int, dirX:int, dirY:int, finishingMovement:Boolean):Boolean {			if(this._game.movementType == Game.TILE_BY_TILE && !finishingMovement) {				if(object.targetTileMovement != null) {					return false;				} else if(!object.canMove) {					return false;				} else if((object.moveDirX != 0 || object.moveDirY != 0) && (object.moveDirX != moveDirX || object.moveDirY != moveDirY || object.dirX != dirX || object.dirY != dirY)) {					object.targetTileMovement = new TargetTileMovement(object.xTile + object.moveDirX, object.yTile + object.moveDirY, object.dirX, object.dirY);					this.finishTileMovement(object as Hero);					return false;				} else {					var distanceFromXEdge:uint;					var distanceFromYEdge:uint;					if(						object.xTile + moveDirX == this._game.gameTiles[0].length+1 ||						object.xTile + moveDirX == -1 ||						object.yTile + moveDirY == this._game.gameTiles.length+1 ||						object.yTile + moveDirY == -1					) {						distanceFromXEdge = (object.x < this._game.tilesContainer.width/2) ? object.x : this._game.tilesContainer.width - object.x;						distanceFromYEdge = (object.y < this._game.tilesContainer.height/2) ? object.y : this._game.tilesContainer.height - object.y;					} else if(this._game.gameTiles[object.xTile + moveDirX][object.yTile + moveDirY].solid) {						distanceFromXEdge = (object.x < this._game.gameTiles[object.xTile + moveDirX][object.yTile + moveDirY].x) ? this._game.gameTiles[object.xTile + moveDirX][object.yTile + moveDirY].x - object.x : object.x - (this._game.gameTiles[object.xTile + moveDirX][object.yTile + moveDirY].x + this._game.tileW);						distanceFromYEdge = (object.y < this._game.gameTiles[object.xTile + moveDirX][object.yTile + moveDirY].y) ? this._game.gameTiles[object.xTile + moveDirX][object.yTile + moveDirY].y - object.y : object.y - (this._game.gameTiles[object.xTile + moveDirX][object.yTile + moveDirY].y + this._game.tileH);					}					if(						(distanceFromXEdge && distanceFromYEdge) && (							distanceFromXEdge <= this._game.tileW / 2 ||							distanceFromYEdge <= this._game.tileH / 2						)					) {						object.x = object.xTile * this._game.tileW + this._game.tileW/2;						object.y = object.yTile * this._game.tileH + this._game.tileH/2;						return false;					}				}			}			return true;		}		/**		 *		 * Moves the passed <code>GameObject</code> in the specified direction.		 *		 * @param object The <code>Moveable</code> to move.		 * @param moveDirX The direction to move the object on the x plane. -1, 0, or 1.		 * @param moveDirY The direction to move the object on the y plane. -1, 0, or 1.		 * @param dirX The direction the object is facing on the x plane. -1, 0, or 1.		 * @param dirY The direction the object is facing on the y plane. -1, 0, or 1.		 * @param jumpState The jumpState of the object.		 * @param finishingMovement <code>true</code> if the call is to finish a movement, <code>false</code> if not.		 *		 */		public function moveObject(object:GameObject, moveDirX:int, moveDirY:int, dirX:int, dirY:int, speed:Number, jumpState:JumpState = null, finishingMovement:Boolean = false):void {			var movementValid:Boolean = this.checkMovement(object, moveDirX, moveDirY, dirX, dirY, finishingMovement);			if(!movementValid && object.targetTileMovement == null) {				object.move(moveDirX, moveDirY, dirX, dirY, jumpState);				object.stopCurAnim();			}			if(movementValid) {				object.move(moveDirX, moveDirY, dirX, dirY, jumpState);				var objectXPos:int;				var objectYPos:int;				var corners:Object = this.getCorners(object.xOnPlane + moveDirX*speed,object.yOnPlane + moveDirY*speed, object);				object.y += moveDirY*speed;				object.yOnPlane += moveDirY*speed;				object.x += moveDirX*speed;				object.xOnPlane += moveDirX*speed;				if(moveDirY < 0) {					if(corners.topLeft.slope == 1 && corners.topLeft.top) {						objectXPos = (object.xOnPlane-object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane-object.halfHeight)%this._game.tileH;						if(objectYPos < (this._game.tileW - objectXPos)) {							object.x += speed;							object.xOnPlane += speed;						}					} else if(corners.topRight.slope == -1 && corners.topRight.top) {						objectXPos = (object.xOnPlane+object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane-object.halfHeight)%this._game.tileH;						if(objectYPos < objectXPos) {							object.x -= speed;							object.xOnPlane -= speed;						}					} else if(corners.topLeft.solid || corners.topRight.solid) {						if(jumpState == null) {							object.y = object.yTile*this._game.tileH+object.halfHeight+1;							object.yOnPlane = object.yTile*this._game.tileH+object.halfHeight+1;						} else {							object.y -= moveDirY*speed;							object.yOnPlane -= moveDirY*speed;						}					}				} else if(moveDirY > 0) {					if(corners.bottomRight.slope == 1 && !corners.bottomRight.top) {						objectXPos = (object.xOnPlane+object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane+object.halfHeight)%this._game.tileH;						if(objectYPos > (this._game.tileW - objectXPos)) {							object.x -= speed;							object.xOnPlane -= speed;						}					} else if(corners.bottomLeft.slope == -1 && !corners.bottomLeft.top) {						objectXPos = (object.xOnPlane-object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane+object.halfHeight)%this._game.tileH;						if(objectYPos > objectXPos) {							object.x += speed;							object.xOnPlane += speed;						}					} else if(corners.bottomLeft.solid || corners.bottomRight.solid) {						if(jumpState == null) {							object.y = (object.yTile+1)*this._game.tileH-object.halfHeight-1;							object.yOnPlane = (object.yTile+1)*this._game.tileH-object.halfHeight-1;						} else {							object.y -= moveDirY*speed;							object.yOnPlane -= moveDirY*speed;						}					}				}				if(moveDirX < 0) {					if(corners.topLeft.slope == 1 && corners.topLeft.top) {						objectXPos = (object.xOnPlane-object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane-object.halfHeight)%this._game.tileH;						if(objectXPos < (this._game.tileH - objectYPos)) {							object.y += speed;							object.yOnPlane += speed;						}					} else if(corners.bottomLeft.slope == -1 && !corners.bottomLeft.top) {						objectXPos = (object.xOnPlane-object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane+object.halfHeight)%this._game.tileH;						if(objectXPos < objectYPos) {							object.y -= speed;							object.yOnPlane -= speed;						}					} else if(corners.bottomLeft.solid || corners.topLeft.solid) {						object.x = object.xTile*this._game.tileW+object.halfWidth+1;						object.xOnPlane = object.xTile*this._game.tileW+object.halfWidth+1;					}				} else if(moveDirX > 0) {					if(corners.bottomRight.slope == 1 && !corners.bottomRight.top) {						objectXPos = (object.xOnPlane+object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane+object.halfHeight)%this._game.tileH;						if(objectXPos > (this._game.tileH - objectYPos)) {							object.y -= speed;							object.yOnPlane -= speed;						}					} else if(corners.topRight.slope == -1 && corners.topRight.top) {						objectXPos = (object.xOnPlane+object.halfWidth)%this._game.tileW;						objectYPos = (object.yOnPlane-object.halfHeight)%this._game.tileH;						if(objectXPos > objectYPos) {							object.y += speed;							object.yOnPlane += speed;						}					} else if(corners.topRight.solid || corners.bottomRight.solid) {						object.x = (object.xTile+1)*this._game.tileW-object.halfWidth-1;						object.xOnPlane = (object.xTile+1)*this._game.tileW-object.halfWidth-1;					}				}				object.xTile = this.getXTilesFromX(object.xOnPlane);				object.yTile = this.getYTilesFromY(object.yOnPlane);				if(this._game.clientHero == object) {					this._game.scroll(object);				}				this.setIndex(object);			}		}		/**		 *		 * Sets the index of the object so depth works.		 *		 * @param object The <code>Moveable</code>.		 * @param stepXTile The x tile at the object's stepX.		 * @param stepYTile The y tile at the object's stepY.		 *		 */		public function setIndex(object:GameObject):void {						var bottomTileY:int  = Math.ceil((object.yOnPlane+object.halfHeight)/this._game.tileH);			var rightTileX:int 	 = Math.ceil((object.xOnPlane+object.halfWidth)/this._game.tileW);			var objectIndex:int  = this._game.tilesContainer.getChildIndex(object);			var objectOffset:int = this._game.gameObjects.length;			var newIndex:int     = (bottomTileY-1)*Number(this._game.map.mapArray[0].length)+rightTileX;						if (objectOffset >= 0){				newIndex += objectOffset;			}			if (object == this._game.clientHero) {				newIndex += 1;			}						if( objectIndex != newIndex) {				this._game.tilesContainer.setChildIndex(object, newIndex);			}		}		/**		 *		 * Starts a jump.		 *		 * @param hero The <code>Hero</code> that is jumping.		 * @param moveDirX The direction the jump is in on the x plane.		 * @param moveDirY The direction the jump is in on the y plane.		 * @param dirX The direction the hero is facing on the x plane.		 * @param dirY The direction the hero is facing on the y plane.		 * @param jumpState The generated <code>JumpState</code>.		 *		 */		public function startJump(hero:GameObject, moveDirX:int, moveDirY:int, dirX:int, dirY:int, jumpState:JumpState):void {			hero.move(moveDirX, moveDirY, dirX, dirY, jumpState);			hero.addEventListener(Event.ENTER_FRAME, this.heroJump);			this.addEventListener(MovementEvent.JUMP_OVER, this.stopJumping);		}		/**		 *		 * Carries out a hero jump.		 *		 */		public function heroJump(event:Event) {			var gameObject:GameObject = event.currentTarget as GameObject;			gameObject.jumpState.currentJumpVelocity -= this._game.gravity;			gameObject.jumpState.distanceFromGround += gameObject.jumpState.currentJumpVelocity;			this.moveObject(gameObject, gameObject.jumpState.jumpMoveDirX, gameObject.jumpState.jumpMoveDirY, gameObject.jumpState.jumpDirX, gameObject.jumpState.jumpDirY, gameObject.jumpState.currentForwardVelocity, gameObject.jumpState);			if(gameObject.jumpState.distanceFromGround > 0) {				gameObject.y = gameObject.yOnPlane - gameObject.jumpState.distanceFromGround;				this.setIndex(gameObject);			} else {				gameObject.y = gameObject.yOnPlane;				this.dispatchEvent(new MovementEvent(MovementEvent.JUMP_OVER, gameObject));			}			this.updateShadow(gameObject);			if(gameObject.clientHero) {				this._game.scroll(gameObject);			}		}		/**		 *		 * Stops a jump when it is over.		 *		 * @param event The <code>MovementEvent</code>.		 *		 */		public function stopJumping(event:MovementEvent):void {			event.gameObject.removeEventListener(Event.ENTER_FRAME, this.heroJump);			event.gameObject.move(event.gameObject.moveDirX, event.gameObject.moveDirY, event.gameObject.dirX, event.gameObject.dirY, null);			event.gameObject.stopCurAnim();		}		/**		 *		 * Updates an object's shadow.		 *		 * @param object The <code>GameObject</code>		 *		 */		public function updateShadow(object:GameObject):void {			object.shadow.x = 0 + (object.xOnPlane - object.x);			object.shadow.y = 0 + (object.yOnPlane - object.y) + object.objectHeight*(1-this._game.tiltRatio);			object.shadow.width = object.objectWidth*(1/this._game.tiltRatio) + ((object.yOnPlane - object.y)/2)*(1/this._game.tiltRatio);			object.shadow.height = object.objectHeight*this._game.tiltRatio + (object.yOnPlane - object.y)/2;			object.shadow.alpha = .7 - (object.yOnPlane - object.y)/100;		}		/**		 *		 * Finishes the tile movement.		 *		 * @param object The <code>Hero</code> that is finishing the tile movement.		 *		 */		public function finishTileMovement(object:GameObject):void {			if(object.targetTileMovement != null && object.parent != null) {				if(!this.continueFinishTileMovement({currentTarget:object})) {					object.addEventListener(Event.ENTER_FRAME, this.continueFinishTileMovement);				}			}		}		/**		 *		 * Finishes the one tile movement.		 *		 * @param event The <code>ENTER_FRAME</code> event.		 *		 * @return <code>true</code> if the movement is over, <code>false</code> if not.  Use only for the first		 * calling in this.finishTileMovement.		 *		 */		public function continueFinishTileMovement(event:Object):Boolean {			var object:GameObject = event.currentTarget as GameObject;			// if parent is null, then player has died, which is sad, but the dead shall not more.			if (object.parent == null || object.targetTileMovement == null)				return true; //  So your movement is over, good bye.						var moveDirX:int = 0;			var moveDirY:int = 0;			var travelDistance:uint = 0;			var remainingPixels:uint = 0;			if(object.x > object.targetTileMovement.x*this._game.tileW+this._game.tileW/2) {				moveDirX = -1;				remainingPixels = (object.xTile - object.targetTileMovement.x)*this._game.tileW + (object.x - this._game.tileW/2)%this._game.tileW;			} else if(object.x < object.targetTileMovement.x*this._game.tileW + this._game.tileW/2) {				moveDirX = 1;				remainingPixels = (object.targetTileMovement.x - object.xTile)*this._game.tileW + (this._game.map.mapArray[0].length*this._game.tileW - object.x - this._game.tileW/2)%this._game.tileW;			} else if(object.y > object.targetTileMovement.y*this._game.tileH + this._game.tileH/2) {				moveDirY = -1;				remainingPixels = (object.yTile - object.targetTileMovement.y)*this._game.tileH + (object.y - this._game.tileH/2)%this._game.tileW;			} else if(object.y < object.targetTileMovement.y*this._game.tileH + this._game.tileH/2) {				moveDirY = 1;				remainingPixels = (object.targetTileMovement.y - object.yTile)*this._game.tileH + (this._game.map.mapArray.length*this._game.tileH - object.y - this._game.tileH/2)%this._game.tileH;			}			if(remainingPixels == 0 || remainingPixels == object.targetTileMovement.remainingPixels) {				object.targetTileMovement = null;				object.removeEventListener(Event.ENTER_FRAME, this.continueFinishTileMovement);				object.stopCurAnim();				this.dispatchEvent(new MovementEvent(MovementEvent.TILE_MOVEMENT_OVER, object));				return true;			} else if(remainingPixels >= object.speed) {				object.targetTileMovement.remainingPixels = remainingPixels;				this.moveObject(object, moveDirX, moveDirY, object.targetTileMovement.dirX, object.targetTileMovement.dirY, object.speed, object.jumpState, true);			} else if(remainingPixels < object.speed && remainingPixels != 0) {				object.targetTileMovement.remainingPixels = remainingPixels;				this.moveObject(object, moveDirX, moveDirY, object.targetTileMovement.dirX, object.targetTileMovement.dirY, remainingPixels, object.jumpState, true);			}			return false;		}		/**		 *		 * Moves the passed <code>GameObject</code> to the specified tile.		 *		 * @param object The <code>GameObject</code> to move.		 * @param tileX The x tile coordinate.		 * @param tileY The y tile coordinate.		 *		 */		public function teleportObject(object:GameObject, tileX:int, tileY:int) {			object.x = object.xOnPlane = (tileX*this._game.tileW) + this._game.tileW/2;			object.y = object.yOnPlane = (tileY*this._game.tileH) + this._game.tileH/2;			object.xTile = tileX;			object.yTile = tileY;			if(this._game.clientHero == object) {				this._game.scroll(object);			}			this.updateShadow(object);		}		/**		 *		 * Gets the x tile coordinate from the x pixel coordinate.		 *		 * @param objectX The object's x pixel coordinate.		 *		 * @return The x tile coordinate.		 *		 */		public function getXTilesFromX(objectX:int):int {			return Math.floor(objectX/this._game.tileW);		}		/**		 *		 * Gets the y tile coordinate from the y pixel coordinate.		 *		 * @param objectY The object's y pixel coordinate.		 *		 * @return The y tile coordinate.		 *		 */		public function getYTilesFromY(objectY:int):int {			return Math.floor(objectY/this._game.tileH);		}	}	}